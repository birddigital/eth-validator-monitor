package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"

	"github.com/birddigital/eth-validator-monitor/graph/generated"
	"github.com/birddigital/eth-validator-monitor/graph/model"
	"github.com/birddigital/eth-validator-monitor/internal/database/models"
	"github.com/birddigital/eth-validator-monitor/internal/logger"
	"github.com/birddigital/eth-validator-monitor/pkg/types"
)

// ID is the resolver for the id field.
func (r *alertResolver) ID(ctx context.Context, obj *models.Alert) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Severity is the resolver for the severity field.
func (r *alertResolver) Severity(ctx context.Context, obj *models.Alert) (types.AlertSeverity, error) {
	panic(fmt.Errorf("not implemented: Severity - severity"))
}

// Type is the resolver for the type field.
func (r *alertResolver) Type(ctx context.Context, obj *models.Alert) (string, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

// Acknowledged is the resolver for the acknowledged field.
func (r *alertResolver) Acknowledged(ctx context.Context, obj *models.Alert) (bool, error) {
	panic(fmt.Errorf("not implemented: Acknowledged - acknowledged"))
}

// CreatedAt is the resolver for the createdAt field.
func (r *alertResolver) CreatedAt(ctx context.Context, obj *models.Alert) (*types.Time, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: Register - register"))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: Login - login"))
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// AddValidator is the resolver for the addValidator field.
func (r *mutationResolver) AddValidator(ctx context.Context, input model.AddValidatorInput) (*models.Validator, error) {
	panic(fmt.Errorf("not implemented: AddValidator - addValidator"))
}

// RemoveValidator is the resolver for the removeValidator field.
func (r *mutationResolver) RemoveValidator(ctx context.Context, index int) (bool, error) {
	panic(fmt.Errorf("not implemented: RemoveValidator - removeValidator"))
}

// UpdateValidatorName is the resolver for the updateValidatorName field.
func (r *mutationResolver) UpdateValidatorName(ctx context.Context, index int, name string) (*models.Validator, error) {
	panic(fmt.Errorf("not implemented: UpdateValidatorName - updateValidatorName"))
}

// AcknowledgeAlert is the resolver for the acknowledgeAlert field.
func (r *mutationResolver) AcknowledgeAlert(ctx context.Context, id string) (*models.Alert, error) {
	panic(fmt.Errorf("not implemented: AcknowledgeAlert - acknowledgeAlert"))
}

// AverageBalance is the resolver for the averageBalance field.
func (r *networkStatsResolver) AverageBalance(ctx context.Context, obj *types.NetworkStats) (*types.BigInt, error) {
	panic(fmt.Errorf("not implemented: AverageBalance - averageBalance"))
}

// TotalStaked is the resolver for the totalStaked field.
func (r *networkStatsResolver) TotalStaked(ctx context.Context, obj *types.NetworkStats) (*types.BigInt, error) {
	panic(fmt.Errorf("not implemented: TotalStaked - totalStaked"))
}

// Timestamp is the resolver for the timestamp field.
func (r *networkStatsResolver) Timestamp(ctx context.Context, obj *types.NetworkStats) (*types.Time, error) {
	panic(fmt.Errorf("not implemented: Timestamp - timestamp"))
}

// Validator is the resolver for the validator field.
func (r *queryResolver) Validator(ctx context.Context, index *int, pubkey *string) (*models.Validator, error) {
	// Use DataLoader to batch load validators
	thunk := r.DataLoaders.ValidatorByIndex.Load(ctx, index)
	return thunk()
}

// Validators is the resolver for the validators field.
func (r *queryResolver) Validators(ctx context.Context, filter *models.ValidatorFilter) ([]*models.Validator, error) {
	// Build filter for repository
	repoFilter := &models.ValidatorFilter{}

	if filter != nil {
		if filter.Indices != nil && len(filter.Indices) > 0 {
			indices := make([]int64, len(filter.Indices))
			for i, idx := range filter.Indices {
				indices[i] = int64(idx)
			}
			repoFilter.ValidatorIndices = indices
		}
		if filter.Pubkeys != nil && len(filter.Pubkeys) > 0 {
			repoFilter.Pubkeys = filter.Pubkeys
		}
		if filter.Monitored != nil {
			repoFilter.Monitored = filter.Monitored
		}
	}

	// Handle pagination
	limit := 50 // default
	offset := 0

	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Cursor != nil {
			// Decode cursor (base64 encoded offset)
			decoded, err := base64.StdEncoding.DecodeString(*pagination.Cursor)
			if err == nil {
				if o, err := strconv.Atoi(string(decoded)); err == nil {
					offset = o
				}
			}
		}
	}

	repoFilter.Limit = limit + 1 // Fetch one extra to determine hasNextPage
	repoFilter.Offset = offset

	// Fetch validators
	validators, err := r.ValidatorRepo.ListValidators(ctx, repoFilter)
	if err != nil {
		log := logger.FromContext(ctx)
		log.Error().
			Err(err).
			Str("operation", "list_validators").
			Interface("filter", repoFilter).
			Msg("failed to fetch validators")
		return nil, fmt.Errorf("failed to fetch validators: %w", err)
	}

	// Determine if there are more pages
	hasNextPage := len(validators) > limit
	if hasNextPage {
		validators = validators[:limit]
	}

	// Build edges and cursors
	edges := make([]*model.ValidatorEdge, len(validators))
	for i, v := range validators {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(offset + i + 1)))
		edges[i] = &model.ValidatorEdge{
			Node:   v,
			Cursor: cursor,
		}
	}

	// Build page info
	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
	}

	if len(edges) > 0 {
		pageInfo.StartCursor = &edges[0].Cursor
		pageInfo.EndCursor = &edges[len(edges)-1].Cursor
		hasPrevPage := offset > 0
		pageInfo.HasPreviousPage = hasPrevPage
	}

	// Get total count
	totalCount, err := r.ValidatorRepo.CountValidators(ctx, repoFilter)
	if err != nil {
		log := logger.FromContext(ctx)
		log.Warn().
			Err(err).
			Str("operation", "count_validators").
			Interface("filter", repoFilter).
			Msg("failed to count validators, using default")
		totalCount = 0
	}

	return &model.ValidatorConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: totalCount,
	}, nil
}

// Network is the resolver for the network field.
func (r *queryResolver) Network(ctx context.Context) (*types.NetworkStats, error) {
	panic(fmt.Errorf("not implemented: Network - network"))
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, filter *models.AlertFilter) ([]*models.Alert, error) {
	panic(fmt.Errorf("not implemented: Alerts - alerts"))
}

// Alert is the resolver for the alert field.
func (r *queryResolver) Alert(ctx context.Context, id string) (*models.Alert, error) {
	panic(fmt.Errorf("not implemented: Alert - alert"))
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: Health - health"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Me - me"))
}

// ValidatorUpdates is the resolver for the validatorUpdates field.
func (r *subscriptionResolver) ValidatorUpdates(ctx context.Context, indices []int) (<-chan *models.Validator, error) {
	panic(fmt.Errorf("not implemented: ValidatorUpdates - validatorUpdates"))
}

// NewAlerts is the resolver for the newAlerts field.
func (r *subscriptionResolver) NewAlerts(ctx context.Context, severity *types.AlertSeverity) (<-chan *models.Alert, error) {
	panic(fmt.Errorf("not implemented: NewAlerts - newAlerts"))
}

// Index is the resolver for the index field.
func (r *validatorResolver) Index(ctx context.Context, obj *models.Validator) (int, error) {
	panic(fmt.Errorf("not implemented: Index - index"))
}

// Status is the resolver for the status field.
func (r *validatorResolver) Status(ctx context.Context, obj *models.Validator) (types.ValidatorStatus, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Balance is the resolver for the balance field.
func (r *validatorResolver) Balance(ctx context.Context, obj *models.Validator) (*model.Balance, error) {
	panic(fmt.Errorf("not implemented: Balance - balance"))
}

// Performance is the resolver for the performance field.
func (r *validatorResolver) Performance(ctx context.Context, obj *models.Validator) (*model.Performance, error) {
	panic(fmt.Errorf("not implemented: Performance - performance"))
}

// Rewards is the resolver for the rewards field.
func (r *validatorResolver) Rewards(ctx context.Context, obj *models.Validator) (*model.Rewards, error) {
	panic(fmt.Errorf("not implemented: Rewards - rewards"))
}

// Alerts is the resolver for the alerts field.
func (r *validatorResolver) Alerts(ctx context.Context, obj *models.Validator) ([]*models.Alert, error) {
	// Use DataLoader to get alerts for this validator
	thunk := r.DataLoaders.AlertsByValidator.Load(ctx, int(obj.ValidatorIndex))
	alerts, err := thunk()
	if err != nil {
		return nil, err
	}

	// Build edges
	edges := make([]*model.AlertEdge, len(alerts))
	for i, alert := range alerts {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(i)))
		edges[i] = &model.AlertEdge{
			Node:   alert,
			Cursor: cursor,
		}
	}

	// Build page info
	pageInfo := &model.PageInfo{
		HasNextPage: false,
	}
	if len(edges) > 0 {
		pageInfo.StartCursor = &edges[0].Cursor
		pageInfo.EndCursor = &edges[len(edges)-1].Cursor
		pageInfo.HasPreviousPage = false
	}

	return &model.AlertConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(alerts),
	}, nil
}

// History is the resolver for the history field.
func (r *validatorResolver) History(ctx context.Context, obj *models.Validator, from *types.Time, to *types.Time) ([]*model.HistoricalSnapshot, error) {
	panic(fmt.Errorf("not implemented: History - history"))
}

// CreatedAt is the resolver for the createdAt field.
func (r *validatorResolver) CreatedAt(ctx context.Context, obj *models.Validator) (*types.Time, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *validatorResolver) UpdatedAt(ctx context.Context, obj *models.Validator) (*types.Time, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}

// Severity is the resolver for the severity field.
func (r *alertFilterResolver) Severity(ctx context.Context, obj *models.AlertFilter, data *types.AlertSeverity) error {
	panic(fmt.Errorf("not implemented: Severity - severity"))
}

// Acknowledged is the resolver for the acknowledged field.
func (r *alertFilterResolver) Acknowledged(ctx context.Context, obj *models.AlertFilter, data *bool) error {
	panic(fmt.Errorf("not implemented: Acknowledged - acknowledged"))
}

// From is the resolver for the from field.
func (r *alertFilterResolver) From(ctx context.Context, obj *models.AlertFilter, data *types.Time) error {
	panic(fmt.Errorf("not implemented: From - from"))
}

// To is the resolver for the to field.
func (r *alertFilterResolver) To(ctx context.Context, obj *models.AlertFilter, data *types.Time) error {
	panic(fmt.Errorf("not implemented: To - to"))
}

// Status is the resolver for the status field.
func (r *validatorFilterResolver) Status(ctx context.Context, obj *models.ValidatorFilter, data *types.ValidatorStatus) error {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Indices is the resolver for the indices field.
func (r *validatorFilterResolver) Indices(ctx context.Context, obj *models.ValidatorFilter, data []int) error {
	panic(fmt.Errorf("not implemented: Indices - indices"))
}

// Alert returns generated.AlertResolver implementation.
func (r *Resolver) Alert() generated.AlertResolver { return &alertResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// NetworkStats returns generated.NetworkStatsResolver implementation.
func (r *Resolver) NetworkStats() generated.NetworkStatsResolver { return &networkStatsResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Validator returns generated.ValidatorResolver implementation.
func (r *Resolver) Validator() generated.ValidatorResolver { return &validatorResolver{r} }

// AlertFilter returns generated.AlertFilterResolver implementation.
func (r *Resolver) AlertFilter() generated.AlertFilterResolver { return &alertFilterResolver{r} }

// ValidatorFilter returns generated.ValidatorFilterResolver implementation.
func (r *Resolver) ValidatorFilter() generated.ValidatorFilterResolver {
	return &validatorFilterResolver{r}
}

type alertResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type networkStatsResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type validatorResolver struct{ *Resolver }
type alertFilterResolver struct{ *Resolver }
type validatorFilterResolver struct{ *Resolver }
